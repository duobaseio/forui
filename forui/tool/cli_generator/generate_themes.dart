import 'package:analyzer/dart/analysis/analysis_context_collection.dart';
import 'package:analyzer/dart/analysis/results.dart';
import 'package:analyzer/dart/ast/ast.dart';
import 'package:analyzer/dart/ast/visitor.dart';
import 'package:code_builder/code_builder.dart';
import 'package:path/path.dart' as p;
import 'package:sugar/sugar.dart';

import 'constructors.dart';
import 'main.dart';

typedef ThemesConstructors = ({
  Map<String, ConstructorMatch> typography,
  Map<String, ConstructorMatch> style,
  Map<(String, String?), List<ThemeConstructor>> themes,
});

typedef ThemeConstructor = ({String theme, String variant, String colors});

final _colors = p.join(library, 'src', 'theme', 'colors.dart');
final _themes = p.join(library, 'src', 'theme', 'themes.dart');

final _typography = RegExp('FTypography');
final _typographyConstructor = RegExp(r'(FTypography)\.inherit');
final _style = RegExp(r'^FStyle$');
final _styleConstructor = RegExp(r'(FStyle)\.inherit');

String generateThemes(Map<(String, String?), String> fragments) {
  final registry = LibraryBuilder()
    ..comments.addAll([header])
    ..body.addAll([
      (EnumBuilder()
            ..docs.addAll(['/// All themes in Forui. Generated by tool/cli_generator.'])
            ..name = 'Theme'
            ..values.addAll([
              for (final MapEntry(key: (theme, variant), value: source) in fragments.entries)
                (EnumValueBuilder()
                      ..name = '$theme${variant == null ? '' : variant.capitalize()}'
                      ..arguments.addAll([
                        literalString('$theme${variant == null ? '' : '-$variant'}'),
                        literalString(source.replaceAll(r'$', r'\$')),
                      ]))
                    .build(),
            ])
            ..fields.addAll([
              (FieldBuilder()
                    ..docs.addAll(['/// The name.'])
                    ..name = 'name'
                    ..type = refer('String')
                    ..modifier = FieldModifier.final$)
                  .build(),
              (FieldBuilder()
                    ..docs.addAll(['/// The code to generate.'])
                    ..name = 'source'
                    ..type = refer('String')
                    ..modifier = FieldModifier.final$)
                  .build(),
            ])
            ..constructors.add(
              (ConstructorBuilder()
                    ..constant = true
                    ..requiredParameters.addAll([
                      Parameter((p) => p..name = 'this.name'),
                      Parameter((p) => p..name = 'this.source'),
                    ]))
                  .build(),
            ))
          .build(),
    ]);

  return metaFormatter.format(registry.build().accept(emitter).toString());
}

Map<(String, String?), String> mapThemes(ThemesConstructors themes) {
  final typography = ConstructorFragment.inline(_typographyConstructor, themes.typography).values.single;
  final style = ConstructorFragment.inline(_styleConstructor, themes.style).values.single;

  final fragments = <(String, String?), String>{};
  for (final MapEntry(:key, value: constructors) in themes.themes.entries) {
    final buffer = StringBuffer();

    for (final constructor in constructors) {
      final themeFunctionName = '${constructor.theme}${constructor.variant.capitalize()}';
      buffer.writeln('''
        FThemeData get $themeFunctionName {
          const colors = ${constructor.colors.startsWith('const ') ? constructor.colors.replaceFirst('const ', '') : constructor.colors};
          
          final typography = _typography(colors: colors);
          final style = _style(colors: colors, typography: typography);
          
          return FThemeData(
            colors: colors,
            typography: typography,
            style: style,
          );
        }
        
        ''');
    }

    buffer
      ..write(typography.source.substring(0, typography.type.length + 1))
      ..write('_')
      ..writeln(typography.source.substring(typography.type.length + 1))
      ..writeln()
      ..write(style.source.substring(0, style.type.length + 1))
      ..write('_')
      ..writeln(style.source.substring(style.type.length + 1));

    fragments[key] = fragmentFormatter.format(buffer.toString());
  }

  return fragments;
}

/// Traverses the library and finds all themes.
Future<ThemesConstructors> traverseThemes(AnalysisContextCollection collection) async {
  final typography = await ConstructorMatch.traverse(collection, _typography, _typographyConstructor, {'FTypography'});
  final style = await ConstructorMatch.traverse(collection, _style, _styleConstructor, {'FStyle'});

  // Parse colors.dart to build a map from field name to inline FColors(...) expression.
  final colors = <String, String>{};
  if (await collection.contextFor(_colors).currentSession.getResolvedUnit(_colors)
      case final ResolvedUnitResult result) {
    final visitor = _ColorsVisitor();
    result.unit.accept(visitor);
    colors.addAll(visitor.colors);
  }

  if (await collection.contextFor(_themes).currentSession.getResolvedUnit(_themes)
      case final ResolvedUnitResult result) {
    final visitor = _ThemesVisitor(colors);
    result.unit.accept(visitor);

    return (typography: typography, style: style, themes: visitor.themes);
  }

  throw Exception('Failed to parse $_colors & $_themes');
}

class _ColorsVisitor extends RecursiveAstVisitor<void> {
  final Map<String, String> colors = {};
  bool _inside = false;

  @override
  void visitClassDeclaration(ClassDeclaration declaration) {
    if (declaration.name.lexeme == 'FColors') {
      _inside = true;
      super.visitClassDeclaration(declaration);
      _inside = false;
    }
  }

  @override
  void visitFieldDeclaration(FieldDeclaration field) {
    if (!_inside || !field.isStatic) {
      return;
    }

    for (final variable in field.fields.variables) {
      if (variable.initializer != null) {
        colors[variable.name.lexeme] = variable.initializer!.toSource();
      }
    }
  }
}

class _ThemesVisitor extends RecursiveAstVisitor<void> {
  final Map<String, String> _colors;
  final Map<(String, String?), List<ThemeConstructor>> themes = {};

  _ThemesVisitor(this._colors);

  @override
  void visitFieldDeclaration(FieldDeclaration field) {
    if (!field.isStatic) {
      return;
    }

    for (final variable in field.fields.variables) {
      final theme = variable.name.lexeme;

      // Match FAutoThemeData(light: () => FPlatformThemeData(...), dark: () => FPlatformThemeData(...))
      if (variable.initializer case final InstanceCreationExpression autoTheme) {
        for (final NamedExpression(:name, :expression)
            in autoTheme.argumentList.arguments.whereType<NamedExpression>()) {
          final variant = name.label.name; // "light" or "dark"

          // () => FPlatformThemeData(desktop: ..., touch: ...)
          if (expression case FunctionExpression(
            body: ExpressionFunctionBody(expression: final InstanceCreationExpression platformTheme),
          )) {
            // Extract colors from the touch variant of FPlatformThemeData
            for (final NamedExpression(:name, :expression)
                in platformTheme.argumentList.arguments.whereType<NamedExpression>()) {
              if (name.label.name != 'touch') {
                continue;
              }

              // () => FThemeData(colors: ...)
              if (expression case FunctionExpression(
                body: ExpressionFunctionBody(expression: final InstanceCreationExpression themeData),
              )) {
                var colors = '';
                for (final expression in themeData.argumentList.arguments.whereType<NamedExpression>()) {
                  if (expression.name.label.name == 'colors') {
                    final source = expression.expression.toSource();
                    // Resolve named constants (e.g. FColors.zincLight) to their inline definition.
                    colors = source.startsWith('FColors.')
                        ? (_colors[source.substring('FColors.'.length)] ?? source)
                        : source;
                  }
                }

                final constructor = (theme: theme, variant: variant, colors: colors);
                (themes[(theme, null)] ??= []).add(constructor);
                (themes[(theme, constructor.variant)] ??= []).add(constructor);
              }
            }
          }
        }
      }
    }
  }
}
